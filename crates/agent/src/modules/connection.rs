use crate::error::Result;
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Query filters applied to retrieving all the connections
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct ConnectionGetAllOptions {
    /// Optional `alias` to filter on
    pub alias: Option<String>,

    // TODO: enum
    /// Optional `connection protocol` to filter on
    pub connection_protocol: Option<String>,

    /// Optional `invitation key` to filter on
    pub invitation_key: Option<String>,

    /// Optional `my did` to filter on
    pub my_did: Option<String>,

    // TODO: enum
    /// Optional `state` to filter on
    pub state: Option<String>,

    /// Optional `their did` to filter on
    pub their_did: Option<String>,

    // TODO: enum
    /// Optional `their role` to filter on
    pub their_role: Option<String>,
}

/// Response from the cloudagent when an invitation is created
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct ConnectionCreateInvitationResponse {
    /// the connection id generated by the cloudagent
    /// this will be used for further functionality
    pub connection_id: String,

    /// Invitation object which contains some metadata about the invitation
    pub invitation: Value,

    /// URL that can be parsed by another agent to accept the invitation
    pub invitation_url: String,

    /// Optional alias if it was supplied when creating the invitation
    pub alias: Option<String>,
}

/// Response from the server when all connections are requested
#[derive(Debug, Serialize, Deserialize)]
pub struct ConnectionGetAllResponse {
    /// List of all the connections returned by the cloudagent
    /// these connections are already filtered on
    pub results: Vec<Connection>,
}

/// A single connection structure
#[derive(Debug, Serialize, Deserialize)]
pub struct Connection {
    /// Their role in the connection process
    pub their_role: String,

    /// When the connection is created
    pub created_at: String,

    /// Your did used in the connection process
    pub my_did: Option<String>,

    /// The connection id used for further functionality
    pub connection_id: String,

    /// Optional their did used in the connection proces
    pub their_did: Option<String>,

    /// The invitation key used
    pub invitation_key: Option<String>,

    /// The current connection state
    pub state: String,

    /// The routing state of the current connection
    pub routing_state: String,

    /// TODO
    pub accept: String,

    /// Their label as set when the connection is initialized
    pub their_label: Option<String>,

    /// What the mode of the invitation is
    pub invitation_mode: String,

    /// State of the connection according to rfc23
    pub rfc23_state: String,

    /// Last time that the connection was updated
    pub updated_at: String,

    /// Alias used when creating the invitation
    pub alias: Option<String>,

    /// Id of the request
    pub request_id: Option<String>,

    /// Id of the invitation message
    pub invitation_msg_id: Option<String>,
}

/// Options supplied by the frontend for creating an invitation
#[derive(Debug, Default)]
pub struct ConnectionCreateInvitationOptions {
    /// Whether we want to auto accept the connection process
    pub auto_accept: bool,

    /// Whether a QR should be outputted to the user
    pub qr: bool,

    /// Whether it should create a special invitation for the toolbox
    pub toolbox: bool,

    /// Whether the invitation is reuseable
    pub multi_use: bool,

    /// Optional custom alias for the connection
    pub alias: Option<String>,
}

/// Options for receiving an invitation
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
// Every field is optional here as there are some collisions between, for example, did and
// routing_key. We rely on the cloudagent for error handling these collisions
// Sadly we cannot skip serializing on the whole struct, we must specify it for each element
pub struct ConnectionReceiveInvitationOptions {
    /// Id of the connection
    #[serde(rename = "@id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Did used for the connection
    #[serde(skip_serializing_if = "Option::is_none")]
    pub did: Option<String>,

    /// Url to an image that can be used as an avatar
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,

    /// Label used for the connection
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,

    /// Keys used by the recipient
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recipient_keys: Option<Vec<String>>,

    /// Routing keys used
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_keys: Option<Vec<String>>,

    /// Service endpoint to call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// Generic cloudagent connection module
#[async_trait]
pub trait ConnectionModule {
    /// Gets all the connections
    async fn get_all(&self, options: ConnectionGetAllOptions) -> Result<ConnectionGetAllResponse>;

    /// Get a connection by id
    async fn get_by_id(&self, id: String) -> Result<Connection>;

    /// Create an invitation
    async fn create_invitation(
        &self,
        options: ConnectionCreateInvitationOptions,
    ) -> Result<ConnectionCreateInvitationResponse>;

    /// Receive and accept a connection
    async fn receive_invitation(
        &self,
        invitation: ConnectionReceiveInvitationOptions,
    ) -> Result<Connection>;
}
